using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;

using Soomla;
using Soomla.Levelup;
using Soomla.Store;
using Soomla.Store.Example;


/// <summary>
/// This class it a WIP testing of SOOMLA LevelUp.
/// </summary>
namespace Soomla.Test {
	public class BasicTest : MonoBehaviour {

		private const string TAG = "SOOMLA-TEST BasicTest";

		// used for testing ad-hoc GatesList generated by World
		public Regex UUID_REGEX =
			new Regex("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");

		// this is the screen (UI) log buffer
		private static string sTestLog;
		// flag indicating error on a test (raised in Assert, need to clear on each test)
		private static bool sAssertionError = false;
		// expected events queue
		// test should push expected events in order here
		// test should assert it's empty when done
		private Queue<Dictionary<string, object>> _eventQueue;

		// some simple GUI for test log
		// TODO: scrolling is shitty on my android, but ok on iPod
		GUIStyle _textStyle = new GUIStyle();
		public Vector2 scrollPosition = Vector2.zero;
		Touch touch;
		float scrollVelocity;
		float timeTouchPhaseEnded;
		float inertiaDuration = 0.5f;

		///
		/// Simple assertions class for tests
		/// 
		private class Assert {

			// get the line in the test that triggered this assertion
			private static string GetAssertCaller() {
				StackTrace st = new StackTrace (true);
				foreach (StackFrame r in st.GetFrames()) {
					string frameLine = string.Format("Filename: {0} Method: {1} Line: {2} Column: {3}  ",
					                                 r.GetFileName(),r.GetMethod(), r.GetFileLineNumber(),
					                                 r.GetFileColumnNumber() );
					//UnityEngine.Debug.LogWarning(frameLine);
					if (Regex.IsMatch(frameLine, @".+BasicTest\.cs")) {
						if (!r.GetMethod().Name.Contains("assert") && !r.GetMethod().Name.Contains("Assert")) {
							return string.Format("{0} at {1}:{2}", r.GetMethod().Name, r.GetFileName(), r.GetFileLineNumber());
						}
					}
				}

				return "ERROR"; // should not get here!
			}

			// make sure cond is true, return true if no assertion error
			public static bool assertTrue(bool cond) {
				if (!cond) {
					// raise flag
					sAssertionError = true;
					// append to UI log
					sTestLog += "<color=red>FAIL!</color>\n";
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += GetAssertCaller() + "\n";
					// unity stacktrace in (device) log
					UnityEngine.Debug.LogException(new Exception("assertTrue"));
//					throw new Exception("assertTrue");
					return false;
				}

				return true;
			}
			public static bool assertFalse(bool cond) {
				if (cond) {
					sAssertionError = true;
					sTestLog += "<color=red>FAIL!</color>\n";
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += GetAssertCaller() + "\n";
					UnityEngine.Debug.LogException(new Exception("assertFalse"));
//					throw new Exception("assertTrue");
					return false;
				}

				return true;
			}
			public static bool assertEquals<T>(T expected, T actual) {
				if (!expected.Equals (actual)) {
					sAssertionError = true;
					sTestLog += string.Format("<color=red>FAIL! expected:{0} actual:{1}</color>\n", expected, actual);
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += GetAssertCaller() + "\n";
					UnityEngine.Debug.LogException(new Exception(expected + "!=" + actual));
//					throw new Exception(expected + "!=" + actual);
					return false;
				}

				return true;
			}
			// comparing doubles requires an epsilon (percision)
			public static bool assertEquals(double actual, double expected, double percision) {
				if (Math.Abs(actual-expected) > percision) {
					sAssertionError = true;
					sTestLog += string.Format("<color=red>FAIL! expected:{0} actual:{1} percision:{2}</color>\n", expected, actual, percision);
					sTestLog += GetAssertCaller() + "\n";
					UnityEngine.Debug.LogException(new Exception(expected + "!=" + actual + "(percision:" + percision + ")"));
//					throw new Exception(expected + "!=" + actual);
					return false;
				}

				return true;
			}

			// when you just want to fail a test with exception you got
			public static void fail(Exception e) {
				sAssertionError = true;
				sTestLog += "<color=red>FAIL!</color>\n";
//				sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
				sTestLog += GetAssertCaller() + "\n";
				UnityEngine.Debug.LogException(e);
//				throw new Exception("fail");
			}
		}

		// singleton Unity Object
		private static BasicTest instance = null;
		void Awake(){
			if(instance == null){ 	//making sure we only initialize one instance.
				instance = this;
				GameObject.DontDestroyOnLoad(this.gameObject);
			} else {					//Destroying unused instances.
				GameObject.Destroy(this);
			}

			// init log and queue
			sTestLog = "";
			_eventQueue = new Queue<Dictionary<string, object>> ();
		}

		/// <summary>
		/// Delete sqlite db file on device or PlayerPrefs in Unity
		/// otherwise stuff will be completed from last test runs etc.
		/// </summary>
		private void deleteLocalDB() {
			string dbName = "store.kv.db";
#if UNITY_EDITOR
			UnityEngine.Debug.LogWarning("TESTING-> PlayerPrefs.DeleteAll()");
			PlayerPrefs.DeleteAll();
#elif UNITY_ANDROID
			//// file approach seems not to work in android
			//// file approach seems to not work
			/// // clear last DB storage so test run anew
			//string dbPath = null;
			// dbPath = Application.persistentDataPath + "/" + dbName;
			//// even replacing the path doesn't
			// dbPath = Regex.Replace(dbPath, "/.+/data/com", "/data/data/com");
			// System.IO.File.Delete (dbPath);
			
			// try via Context (works)
			UnityEngine.Debug.LogWarning("TESTING-> try to delete db via Context.deleteDatabase..");
			AndroidJavaClass jc = new AndroidJavaClass("com.unity3d.player.UnityPlayer"); 
			AndroidJavaObject jo = jc.GetStatic<AndroidJavaObject>("currentActivity");
			bool deleted = jo.Call<bool>("deleteDatabase", new object[] {dbName});
			UnityEngine.Debug.LogWarning ("TESTING-> deleted?=" + deleted);
#elif UNITY_IOS
			// clear last DB storage so test run anew
//			string dbName = "store.kv.db";
			string dbPath = null;
			
			dbPath = "/private" + Application.persistentDataPath + "/../Library/Application Support/" + dbName;
			if (dbPath != null) {
				UnityEngine.Debug.LogWarning ("TESTING-> db file at:" + dbPath);
				bool exists = System.IO.File.Exists(dbPath);
				UnityEngine.Debug.LogWarning ("TESTING-> db file exists?=" + exists);
				if(exists) {
					UnityEngine.Debug.LogWarning ("TESTING-> DELETE db file at:" + dbPath);
				}
			}
#endif
		}

		// Use this for initialization
		void Start () {

			// set UI stuff
			_textStyle.wordWrap = true;
			_textStyle.richText = true;	
			_textStyle.normal.textColor = Color.white;
			_textStyle.fontSize = Screen.width / 30;
			
			// register events
			StoreEvents.OnSoomlaStoreInitialized += onSoomlaStoreInitialized;
			StoreEvents.OnGoodBalanceChanged += onGoodBalanceChanged;
			StoreEvents.OnMarketItemsRefreshFinished += onMarketItemsRefreshFinished;
			
			LevelUpEvents.OnGateOpened += onGateOpen;
			LevelUpEvents.OnLevelEnded += onLevelEnded;
			LevelUpEvents.OnLevelStarted += onLevelStarted;
			LevelUpEvents.OnMissionCompleted += onMissionCompleted;
			LevelUpEvents.OnMissionCompletionRevoked += onMissionCompletedRevoked;
			LevelUpEvents.OnScoreRecordChanged += onScoreRecordChanged;
			LevelUpEvents.OnWorldCompleted += onWorldCompleted;
			
			CoreEvents.OnRewardGiven += onRewardGiven;
			CoreEvents.OnRewardTaken += onRewardTaken;
			
			// delete sqlite or PlayerPrefs before running tests
			// otherwise stuff will be completed from last test runs etc.
			deleteLocalDB ();

			// TBD: these are are initialized internally
			// TBD: is that ok, or from outside?
//			CoreEvents.Initialize ();
//			LevelUpEvents.Initialize ();

//			MuffinRushAssets muffinAssets = new MuffinRushAssets ();
			IStoreAssets testAssets = new TestAssets();
			SoomlaUtils.LogDebug(TAG, "IStoreAssets:" + testAssets.ToString ());
			SoomlaStore.Initialize (testAssets);

			Soomla.Profile.SoomlaProfile.Initialize();
		}

		// run tests after store is initialized
		public void onSoomlaStoreInitialized() {
			StartCoroutine(runTests());
		}

		public void onMarketItemsRefreshFinished(List<MarketItem> items) {
//			StoreInventory.BuyItem("item_balance_gate");
		}

		/// <summary>
		/// Runs the tests.
		/// Notice the structure, wait for each test to complete
		/// using <code>yield return</code> otherwise events could get out
		/// of order
		/// 
		/// </summary>
		/// <returns>The tests.</returns>
		private IEnumerator/*void*/ runTests() {
			// Android: FAIL
//			yield return StartCoroutine(testScoreAsc ());
//			// Android: FAIL
//			yield return StartCoroutine(testScoreDsc ());
//			// Andorid: FAIL
//			yield return StartCoroutine(testRangeScoreOverflow ());
//			// Android: PASS
//			yield return StartCoroutine(testBalanceMission ());
//			// Android: PASS
//			// iOS CRASH (TODO: should not call [super init] on Mission)
//			yield return StartCoroutine(testRecordMission ());
//			// iOS: Reward Taken FAIL
//			// Android: PASS
//			yield return StartCoroutine(testChallenge ());
			// Android: PASS
			yield return StartCoroutine(testLevel ());
			// Android: FAIL
//			yield return StartCoroutine (testRecordGateWithRangeScore ());

			yield return null;
		}

		// util
		private static string DictToString(Dictionary<string, object> dict) {
			string str = "";
			foreach( KeyValuePair<string, object> kvp in dict )
			{
				str += string.Format("Key = {0}, Value = {1}", 
				                          kvp.Key, kvp.Value) + "\n";
			}

			return str;
		}

		// read all left over events in queue, print them out
		// and clear queue
		private void dumpQueue(string testName) {
			string queueLog = "";
			while (_eventQueue.Count > 0) {
				Dictionary<string, object> expectedEvent = _eventQueue.Dequeue();
				queueLog = DictToString(expectedEvent);
				string msg = testName + ">>> unconsumed event:" + queueLog;
				sTestLog += msg;
				UnityEngine.Debug.LogError(msg);
			}
		}

		// touch events handling (Scroll) and exit (back) on Android
		void Update() {
			if (Application.platform == RuntimePlatform.Android) {
				if (Input.GetKeyUp(KeyCode.Escape)) {
					//quit application on back button
					Application.Quit();
					return;
				}
			}

			if(Input.touchCount > 0)
			{
				touch = Input.touches[0];
				if (touch.phase == TouchPhase.Moved)
				{
					scrollPosition.x += touch.deltaPosition.x;
					scrollPosition.y += touch.deltaPosition.y;
				}
				if (touch.phase == TouchPhase.Ended)
				{
					// impart momentum, using last delta as the starting velocity
					// ignore delta < 10; rounding issue can cause ultra-high velocity
					if (Mathf.Abs(touch.deltaPosition.y) >= 10) {
						scrollVelocity = (int)(touch.deltaPosition.y / touch.deltaTime);
					}
					timeTouchPhaseEnded = Time.time;

				}
			}
			if (Input.touchCount != 1)
			{
				if ( scrollVelocity != 0.0f )
				{
					// slow down over time
					float t = (Time.time - timeTouchPhaseEnded) / inertiaDuration;
					float frameVelocity = Mathf.Lerp(scrollVelocity, 0, t);
					scrollPosition.y += frameVelocity * Time.deltaTime;
					
					// after N seconds, we've stopped
					if (t >= inertiaDuration) scrollVelocity = 0.0f;
				}
				return;
			}
		}

		// very simple GUI for tests log on device
		void OnGUI() {

			GUILayout.BeginArea (new Rect(10, 10, Screen.width-10, Screen.height-10));
			scrollPosition = GUILayout.BeginScrollView (scrollPosition, GUILayout.Width (Screen.width-10), GUILayout.Height (Screen.height-10));
			/*changes made in the below 2 lines */
			GUI.skin.box.wordWrap = true;     // set the wordwrap on for box only.
			GUILayout.Box(sTestLog, _textStyle);        // just your message as parameter.			
			GUILayout.EndScrollView ();			
			GUILayout.EndArea();

//			Rect rcView = new Rect (10, 10, Screen.width - 10, Screen.height - 10);
//			scrollPosition = GUI.BeginScrollView(scrollPosition, new Vector2(0, Mathf.Infinity), rcView);
//			GUI.TextArea (rcView, sTestLog, _textStyle);
//			GUI.EndScrollView ();
		}

		// rafa's test?
		private void createFruitsGoblins() {
		
			World mainWorld = new World("main_world");

			Score s = new Score("numberScore");
			World machineA = new World("machine_a");
			World machineB = new World("machine_b");
			World machineC = new World("machine_c");
			World machineD = new World("machine_d");

			machineA.BatchAddLevelsWithTemplates(20, null, s, null);
			machineB.BatchAddLevelsWithTemplates(20, null, s, null);
			machineC.BatchAddLevelsWithTemplates(20, null, s, null);
			machineD.BatchAddLevelsWithTemplates(20, null, s, null);

			mainWorld.AddInnerWorld(machineA);
			mainWorld.AddInnerWorld(machineB);
			mainWorld.AddInnerWorld(machineC);
			mainWorld.AddInnerWorld(machineD);

			BadgeReward bronzeMedal = new BadgeReward("badge_bronzeMedal", "Bronze Medal");
			BadgeReward silverMedal = new BadgeReward("badge_silverMedal", "Silver Medal");
			BadgeReward goldMedal = new BadgeReward("badge_goldMedal", "Gold Medal");
			VirtualItemReward perfectMedal = new VirtualItemReward("item_perfectMedal", "Perfect Medal", "perfect_medal", 1);

			SoomlaLevelUp.Initialize(mainWorld);
//			((Level)LevelUp.GetInstance().GetWorld("machine_a_level_1")).Start();
			/** Testing **/

			Level lvl1 = (Level)machineA.GetInnerWorldAt(0);
			lvl1.AssignReward(goldMedal);
		}
			

		// TESTS ported from Android tests


		/// <summary>
		/// Tests the level
		/// 
		/// Will document this test more thoroughly as the guide for the rest
		/// 
		/// </summary>
		/// <returns>The level.</returns>
		private IEnumerator testLevel() {
			// clear error flag
			sAssertionError = false;
			// print some info
			sTestLog += "testLevel...\n";	
			UnityEngine.Debug.LogWarning("testLevel SOOMLA");

			// setup SoomlaLevelUp structure/objects
			Level lvl1 = new Level("lvl1");
			lvl1.AddScore(new Score("numberScore"));
			SoomlaLevelUp.Initialize(lvl1);
			
			// no gates
			Assert.assertTrue(lvl1.CanStart());
			Assert.assertTrue(lvl1.State == Level.LevelState.Idle);

			// clear event queue, very important!
			_eventQueue.Clear ();

			// setup expected events from next action
			Dictionary<string, object> evtScoreRecoredChanged = new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", "numberScore" }, 
				{ "val", 0.0 }
			};
			Dictionary<string, object> evtLvlStarted = new Dictionary<string, object> {
				{ "handler", "onLevelStarted" },
				{ "id", "lvl1" }
			};
			Dictionary<string, object> evtLvlEnded = new Dictionary<string, object> {
				{ "handler", "onLevelEnded" },
				{ "id", "lvl1" }
			};
			Dictionary<string, object> evtWorldCompleted = new Dictionary<string, object> {
				{ "handler", "onWorldCompleted" },
				{ "id", "lvl1" }
			};

			_eventQueue.Enqueue (evtLvlStarted); // level started
			_eventQueue.Enqueue (evtLvlEnded); // level ended
			_eventQueue.Enqueue (evtScoreRecoredChanged); // level started
			_eventQueue.Enqueue (evtWorldCompleted); // world completed

			// this should trigger the events
			lvl1.Start();
			Assert.assertTrue(lvl1.State == Level.LevelState.Running);

			// this both waits for the events and tests the level timing
			yield return new WaitForSeconds(1);
			// check level time measure
			double playDuration = lvl1.GetPlayDurationMillis();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";
			Assert.assertTrue(playDuration >= 1000);
			Assert.assertFalse(playDuration > 2500);

			lvl1.Pause();
			yield return new WaitForSeconds(1);
			// make sure no changes after pause
			playDuration = lvl1.GetPlayDurationMillis();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";;
			Assert.assertTrue(playDuration >= 1000);
			Assert.assertFalse(playDuration > 2500);
			Assert.assertTrue(lvl1.State == Level.LevelState.Paused);
			
			lvl1.Start();
			yield return new WaitForSeconds(1);
			// make sure working after resume
			playDuration = lvl1.GetPlayDurationMillis();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";;
			Assert.assertTrue(playDuration >= 2000);
			Assert.assertFalse(playDuration > 3500);
			Assert.assertTrue(lvl1.State == Level.LevelState.Running);

			lvl1.End(true);
			Assert.assertTrue(lvl1.State == Level.LevelState.Completed);
			Assert.assertTrue(lvl1.IsCompleted());
			
//			lvl1.SetCompleted(true);
//			Assert.assertTrue(lvl1.IsCompleted());

			// it seems there is a delay of ~0.5-1.0 seconds of saving to storage
			Assert.assertEquals(playDuration, lvl1.GetSlowestDurationMillis(), 1000);
			Assert.assertEquals(playDuration,lvl1.GetFastestDurationMillis(), 1000);
			Assert.assertEquals(1, lvl1.GetTimesPlayed());
			Assert.assertEquals(1, lvl1.GetTimesStarted());		

			// wait for any leftover events
			yield return new WaitForSeconds (2);

			// make sure event queue is empty
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}

			// print/GUI some indications
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}

		public IEnumerator testScoreAsc() {
			sAssertionError = false;
			sTestLog += "testScoreAsc...\n";
			UnityEngine.Debug.LogWarning("testScoreAsc SOOMLA");

			bool higherIsBetter = true;
			string scoreId = "score_asc";
			Score scoreAsc = new Score(scoreId, "ScoreAsc", higherIsBetter);		

			Level lvl = new Level ("lvl_testScoreAsc");
			lvl.AddScore(scoreAsc);
			SoomlaLevelUp.Initialize (lvl);
//			LevelUp.GetInstance ().InitialWorld.Scores.Add (scoreAsc);

			_eventQueue.Clear ();

			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.StartValue = 0;
			scoreAsc.Inc(1);
			Assert.assertEquals(1, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.Dec(1);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.Inc(10);
			Assert.assertEquals(10, scoreAsc.GetTempScore(), 0.01);
	//		//mExpectedRecordValue = 10;
			SoomlaUtils.LogWarning (TAG, "Enqueue 10.0");
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 10.0 }
			});
			scoreAsc.Reset(true);
			Assert.assertEquals(10, scoreAsc.Latest, 0.01);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.SetTempScore(20);
	//		//mExpectedRecordValue = 0;
//				_eventQueue.Enqueue (new Dictionary<string, object> {
//				{ "handler", "onScoreRecordChanged" },
//				{ "id", scoreId }, 
//				{ "val", 0.0 }
//			});
			scoreAsc.Reset(false);
			Assert.assertEquals(0, scoreAsc.Latest, 0.01);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.SetTempScore(30);
			Assert.assertTrue(scoreAsc.HasTempReached(30));
			Assert.assertFalse(scoreAsc.HasTempReached(31));
	//		//mExpectedRecordValue = 30;
			SoomlaUtils.LogWarning (TAG, "Enqueue 30.0");
				_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 30.0 }
			});
			scoreAsc.Reset(true);
			Assert.assertEquals(30, scoreAsc.Latest, 0.01);
			Assert.assertEquals(30, scoreAsc.Record, 0.01);
			scoreAsc.SetTempScore(15);
	//		//mExpectedRecordValue = 30;
			SoomlaUtils.LogWarning (TAG, "Enqueue 30.0");
				_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 30.0 }
			});		
			scoreAsc.Reset(true);
			Assert.assertEquals(15, scoreAsc.Latest, 0.01);
			Assert.assertEquals(30, scoreAsc.Record, 0.01);
			Assert.assertTrue(scoreAsc.HasRecordReached(30));
			Assert.assertFalse(scoreAsc.HasRecordReached(31));
					
			yield return new WaitForSeconds (2);

			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}

			UnityEngine.Debug.LogWarning("Done! SOOMLA");

			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}
	
		public IEnumerator testScoreDsc() {
			sAssertionError = false;
			sTestLog += "testScoreDsc...\n";
			UnityEngine.Debug.LogWarning("testScoreDsc SOOMLA");
			double desiredRecord = 20;
			string scoreId = "score_dsc";
			Score scoreDsc = new Score(scoreId, "ScoreDsc", false);
			scoreDsc.StartValue = 100;

			Level lvl = new Level ("lvl_testScoreDsc");
			lvl.AddScore(scoreDsc);
			SoomlaLevelUp.Initialize (lvl);
//			LevelUp.GetInstance ().InitialWorld.Scores.Add (scoreDsc);

			_eventQueue.Clear ();

			//mExpectedScoreEventId = scoreId;
			//mExpectedRecordValue = 100;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 100.0 }
			});

			scoreDsc.Reset(false);
			Assert.assertEquals(100, scoreDsc.GetTempScore(), 0.01);
			
			scoreDsc.Dec(50);
			Assert.assertEquals(50, scoreDsc.GetTempScore(), 0.01);
			//mExpectedRecordValue = 50;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 50.0 }
			});
			scoreDsc.Reset(true); // start value is 100
			Assert.assertEquals(50, scoreDsc.Latest, 0.01);
			Assert.assertEquals(100, scoreDsc.GetTempScore(), 0.01);
			scoreDsc.SetTempScore(20);
			//mExpectedRecordValue = 20;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 20.0 }
			});

			scoreDsc.Reset(true);
			Assert.assertEquals(20, scoreDsc.Latest, 0.01);
			Assert.assertEquals(20, scoreDsc.Record, 0.01);
			scoreDsc.SetTempScore(30);
			//mExpectedRecordValue = 20;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 20.0 }
			});
			scoreDsc.Reset(true);
			Assert.assertEquals(30, scoreDsc.Latest, 0.01);
			Assert.assertEquals(20, scoreDsc.Record, 0.01);
			Assert.assertTrue(scoreDsc.HasRecordReached(20));
			Assert.assertFalse(scoreDsc.HasRecordReached(19));

			yield return new WaitForSeconds (2);
			
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}
			
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}
		
		
		public IEnumerator testRangeScoreOverflow() {
			sAssertionError = false;
			sTestLog += "testRangeScoreOverflow...\n";
			UnityEngine.Debug.LogWarning("testRangeScoreOverflow SOOMLA");
			string scoreIdUp = "testRangeScoreOverflow_score_up_id";
			RangeScore rangeScoreUp = new RangeScore(scoreIdUp, "RangeScore", true, new RangeScore.SRange(0, 100));
			string scoreIdDown = "testRangeScoreOverflow_score_down_id";
			RangeScore rangeScoreDown = new RangeScore(scoreIdDown, "RangeScore", false, new RangeScore.SRange(0, 100));

			SoomlaLevelUp.Initialize (new Level ("testRangeScoreOverflow"));
			SoomlaLevelUp.InitialWorld.Scores.Add (scoreIdUp, rangeScoreUp);
			SoomlaLevelUp.InitialWorld.Scores.Add (scoreIdDown, rangeScoreDown);

			_eventQueue.Clear ();

			//mExpectedScoreEventId = scoreIdUp;
			//mExpectedRecordValue = 0;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreIdUp }, 
				{ "val", 0.0 }
			});
		
			rangeScoreUp.Inc(101);
			Assert.assertEquals(100, rangeScoreUp.GetTempScore(), 0.01);
			rangeScoreUp.Reset(false);
			rangeScoreUp.Inc(5);
			rangeScoreUp.Dec(10);
			Assert.assertEquals(0, rangeScoreUp.GetTempScore(), 0.01);
			
			//mExpectedScoreEventId = scoreIdDown;
			//mExpectedRecordValue = 100;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreIdDown }, 
				{ "val", 100.0 }
			});
			
			rangeScoreDown.Dec(101);
			Assert.assertEquals(0, rangeScoreDown.GetTempScore(), 0.01);
			rangeScoreDown.Reset(false);
			rangeScoreDown.Dec(5);
			rangeScoreDown.Inc(10);
			Assert.assertEquals(100, rangeScoreDown.GetTempScore(), 0.01);

			// wait for events
			yield return new WaitForSeconds (2);
			
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}
			
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}
		
		
		public IEnumerator testRecordMission() {
			sAssertionError = false;
			sTestLog += "testRecordMission...\n";
			UnityEngine.Debug.LogWarning("testRecordMission SOOMLA");

			string missionId = "record_mission";
			string scoreId = "record_mission_score";
			string rewardId = "record_mission_reward_badge_id";
			double desiredScore = 55.0;
			BadgeReward badgeReward = new BadgeReward(rewardId, "RecordMissionBadge");
			List<Reward> rewards = new List<Reward>();
			rewards.Add(badgeReward);
			Score score = new Score(scoreId, "RecordMissionScore", true);
			RecordMission recordMission = new RecordMission(
				missionId, "RecordMission", rewards, scoreId, desiredScore);

			Level lvl1 = new Level ("lvl_testRecordMission");
			Challenge challenge = new Challenge("challenge_record_mission", "ChlgRecordMission", new List<Mission> {recordMission});
			SoomlaLevelUp.Initialize (lvl1);
			SoomlaLevelUp.InitialWorld.Missions.Add(challenge);

			_eventQueue.Clear ();
			//mExpectedScoreEventId = scoreId;
			//mExpectedRecordValue = desiredScore;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", desiredScore }
			});
			//mExpectedMissionEventId = missionId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId }, 
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardGiven" },
				{ "id", rewardId }, 
			});

			Assert.assertFalse(recordMission.IsCompleted());
			Assert.assertFalse(badgeReward.Owned);
			
			score.SetTempScore(desiredScore);
			score.Reset(true);

			// wait for events
			yield return new WaitForSeconds (2);

			Assert.assertTrue(recordMission.IsCompleted());
			Assert.assertTrue(badgeReward.Owned);
			
			// test revoke
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompletedRevoked" },
				{ "id", missionId }, 
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardTaken" },
				{ "id", rewardId }, 
			});

			recordMission.Complete();

			// wait for events
			yield return new WaitForSeconds (2);
			
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}
			
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}
		
		
		public IEnumerator testBalanceMission() {
			sAssertionError = false;
			sTestLog += "testBalanceMission...\n";
			string missionId = "balance_mission_id";
			string balanceMissionItemId = "balance_mission_item_id";
			string rewardId = "balance_mission_reward_id";
			string rewardItemId = "balance_mission_reward_item_id";
			
			VirtualItemReward virtualItemReward = new VirtualItemReward(rewardId, "ItemReward", rewardItemId, 1);
			List<Reward> rewards = new List<Reward>();
			rewards.Add(virtualItemReward);
			BalanceMission balanceMission = new BalanceMission(
				missionId, "BalanceMission",
				rewards, balanceMissionItemId, 5);

			Level lvl1 = new Level ("lvl_testBalanceMission");
			Challenge challenge = new Challenge("challenge_balance_mission", "ChlgBalanceMission", new List<Mission> {balanceMission});
			SoomlaLevelUp.Initialize (lvl1);
			SoomlaLevelUp.InitialWorld.Missions.Add(challenge);

			_eventQueue.Clear ();

			// assert basics
			Assert.assertFalse(balanceMission.IsCompleted());
			Assert.assertFalse(virtualItemReward.Owned);
			try {
				Assert.assertEquals(0, StoreInventory.GetItemBalance(TestAssets.ITEM_ID_BALANCE_MISSION));
			} catch (VirtualItemNotFoundException e) {
				Assert.fail(e);
			}
			
			// give less and assert false completed/rewarded
			// set event expectations
			//mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION, 3, 3));
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onGoodBalanceChanged" },
				{ "itemId", TestAssets.ITEM_ID_BALANCE_MISSION }, 
				{ "added", 3 }, 
				{ "balance", 3 }
			});
			try {
				StoreInventory.GiveItem(balanceMissionItemId, 3);
			} catch (VirtualItemNotFoundException e) {
				Assert.fail(e);
			}
			
			// set event expectations
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION, 2, 5));
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onGoodBalanceChanged" },
				{ "itemId", TestAssets.ITEM_ID_BALANCE_MISSION }, 
				{ "added", 2 }, 
				{ "balance", 5 }
			});
			//mExpectedMissionEventId = missionId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId }
			});
			// this will happen directly after
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION_REWARD, 1, 1));
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onGoodBalanceChanged" },
				{ "itemId", TestAssets.ITEM_ID_BALANCE_MISSION_REWARD }, 
				{ "added", 1 }, 
				{ "balance", 1 }
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardGiven" },
				{ "id", rewardId }
			});
			
			try {
				StoreInventory.GiveItem(balanceMissionItemId, 2);
			} catch (VirtualItemNotFoundException e) {
				Assert.fail(e);
			}

			// wait for store events
			yield return new WaitForSeconds (2);
			
			Assert.assertTrue(balanceMission.IsCompleted());
			Assert.assertTrue(virtualItemReward.Owned);

			yield return new WaitForSeconds (2);
			
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}
			
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}

			yield return null;
		}
		
		
		public IEnumerator testChallenge() {
			sAssertionError = false;
			sTestLog += "testChallenge...\n";
			UnityEngine.Debug.LogWarning("testChallenge SOOMLA");

//			string missionId1 = "challenge_mission1";
//			Mission mission1 = new ActionMission(missionId1, "ChallengeMission1");
//			string missionId2 = "challenge_mission2";
//			Mission mission2 = new ActionMission(missionId2, "ChallengeMission2");
//			List<Mission> missions = new List<Mission>();
//			missions.Add(mission1);
//			missions.Add(mission2);
//			List<Reward> rewards = new List<Reward>();
//			string rewardId = "challenge_badge_reward_id";
//			BadgeReward badgeReward = new BadgeReward(rewardId, "ChallengeBadgeRewardId");
//			rewards.Add(badgeReward);
//			string challengeId = "challenge_id";
//			Challenge challenge = new Challenge(challengeId, "Challenge", missions, rewards);

//			Level lvlChlg = new Level ("lvlChlg", null, null, new List<Challenge> () {challenge});
//			LevelUp.GetInstance ().Initialize (lvlChlg, null);
//			// TODO: will this create the challenge instance?
//			LevelUp.GetInstance().GetCompletedLevelCount ();
//
//			_eventQueue.Clear ();
//
//			Assert.assertFalse(challenge.IsCompleted());
//			
//			//mExpectedMissionEventId = missionId1;
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onMissionCompleted" },
//				{ "id", missionId1 }, 
//			});
//
//			mission1.SetCompleted(true);
//
//			// wait for events
//			yield return new WaitForSeconds (2);
//			
//			//mExpectedMissionEventId = missionId2;
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onMissionCompleted" },
//				{ "id", missionId2 }, 
//			});
//			//mExpectedChallengeId = challengeId;
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onMissionCompleted" },
//				{ "id", challengeId }, 
//			});
//			//mExpectedRewardEventId = rewardId;
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onRewardGiven" },
//				{ "id", rewardId }, 
//			});
//			
//			Assert.assertFalse(challenge.IsCompleted());
//			Assert.assertFalse(badgeReward.Owned);
//			
//			mission2.SetCompleted(true);
//
//			// wait for events
//			yield return new WaitForSeconds (2);
//
//			Assert.assertTrue(challenge.IsCompleted());
//			
//			// test revoke
//			//mExpectedMissionEventId = missionId1;
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onMissionCompletedRevoked" },
//				{ "id", missionId1 }, 
//			});
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onMissionCompletedRevoked" },
//				{ "id", challengeId }, 
//			});
//			// TODO: (currently not taken on iOS)
//			_eventQueue.Enqueue(new Dictionary<string, object> {
//				{ "handler", "onRewardTaken" },
//				{ "id", rewardId }, 
//			});
//			mission1.SetCompleted(false);
//
//			// wait for events
//			yield return new WaitForSeconds (2);
//
//			Assert.assertFalse(challenge.IsCompleted());
//			// TODO: should this be true or false? (should it be taken?)
//			// (currently not taken on iOS)
//			Assert.assertFalse(badgeReward.Owned);	
//
//			yield return new WaitForSeconds (2);
//			
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
//			}
//			
//			UnityEngine.Debug.LogWarning("Done! SOOMLA");
//			
//			if (!sAssertionError) {
//				sTestLog += "<color=green>SUCCESS</color>\n";
//			}
//
			yield return null;
		}
		
		
//		public void testRewards() {
//			bool given;
//			//        BadgeReward badgeReward = new BadgeReward();
//			//        badgeReward.setRepeatable(false);
//			//        Assert.assertFalse(badgeReward.Owned);
//			//        given = badgeReward.give();
//			//        Assert.assertTrue(given);
//			//        given = badgeReward.give();
//			//        Assert.assertFalse(given);
//			//        Assert.assertTrue(badgeReward.Owned);
//			//
//			//        RandomReward randomReward = new RandomReward();
//			//        SequenceReward sequenceReward = new SequenceReward();
//			
//			string rewardId = "vi_reward";
//			VirtualItemReward virtualItemReward = new VirtualItemReward(rewardId, "VIReward", 3, ITEM_ID_VI_REWARD);
//			virtualItemReward.Repeatable = true;
//			
//			try {
//				Assert.assertEquals(0, StoreInventory.GetItemBalance(ITEM_ID_VI_REWARD));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// expected events (async)
//			//mExpectedRewardEventId = rewardId;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_VI_REWARD, 3, 3));
//			
//			given = virtualItemReward.Give();
//			Assert.assertTrue(given);
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_VI_REWARD, 3, 6));
//			
//			given = virtualItemReward.Give();
//			Assert.assertTrue(given);
//			
//			try {
//				Assert.assertEquals(6, StoreInventory.GetItemBalance(ITEM_ID_VI_REWARD));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//		}
		
		
		public IEnumerator testRecordGateWithRangeScore() {
			sAssertionError = false;
			sTestLog += "testRecordGateWithRangeScore...\n";
			UnityEngine.Debug.LogWarning("testRecordGateWithRangeScore SOOMLA");

			string lvl1Id = "lvl1_recordgate_rangescore";
			string lvl2Id = "lvl2_recordgate_rangescore";
			string scoreId = "range_score";
			RangeScore rangeScore = new RangeScore(scoreId, "RangeScore", true, new RangeScore.SRange(0, 100));
			string recordGateId = "record_gate";
			RecordGate recordGate = new RecordGate(recordGateId, scoreId, 100);

			World world = new World ("world_recordgate_rangescore");
			Level lvl1 = new Level(lvl1Id);
			Level lvl2 = new Level(lvl2Id, recordGate, 
			                       new Dictionary<string, Score>(),
			                       new List<Mission>());
			lvl1.Scores.Add(scoreId, rangeScore);


			SoomlaLevelUp.Initialize(world);
			SoomlaLevelUp.InitialWorld.AddInnerWorld (lvl1);
			SoomlaLevelUp.InitialWorld.AddInnerWorld (lvl2);
			
			// open level
			Assert.assertTrue(lvl1.CanStart());
			// protected by gate
			Assert.assertFalse(lvl2.CanStart());
			
			//mExpectedWorldEventId = lvl1Id;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onLevelStarted" },
				{ "id", lvl1Id }, 
			});
			
			lvl1.Start();

			yield return new WaitForSeconds (1);
			
			int i = 0;
			Assert.assertFalse(recordGate.IsOpen());
			Assert.assertFalse(recordGate.CanOpen());
			while (i < 100) {
				rangeScore.Inc(1);
				++i;
			}
			Assert.assertFalse(recordGate.IsOpen());
			Assert.assertFalse(recordGate.CanOpen());

			//mExpectedScoreEventId = scoreId;
			//mExpectedRecordValue = 100;
			//mExpectedGateEventId = recordGateId;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 100 }
			});
			// gate canOpen
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onLevelEnded" },
				{ "id", lvl1Id }, 
			});
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onWorldCompleted" },
				{ "id", lvl1Id }, 
			});
			
			rangeScore.Inc(1);
			
			lvl1.End(true);

			// wait for events
			yield return new WaitForSeconds (2);
			
			Assert.assertFalse(recordGate.IsOpen());
			Assert.assertTrue(recordGate.CanOpen());

			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onGateOpen" },
				{ "id", recordGateId }, 
			});

			bool opened = recordGate.Open();

			// wait for events
			yield return new WaitForSeconds (2);

			Assert.assertTrue(opened);
			Assert.assertTrue(recordGate.IsOpen());
			Assert.assertTrue(recordGate.CanOpen());
			
			Assert.assertTrue(lvl2.CanStart());
			
			//mExpectedWorldEventId = lvl2Id;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onLevelStarted" },
				{ "id", lvl2Id }, 
			});

			lvl2.Start();

			yield return new WaitForSeconds (1);

			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onLevelEnded" },
				{ "id", lvl2Id }, 
			});
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onWorldCompleted" },
				{ "id", lvl2Id }, 
			});

			lvl2.End(true);

			// wait for events
			yield return new WaitForSeconds (2);

			Assert.assertTrue(lvl2.IsCompleted());

			yield return new WaitForSeconds (2);
			
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue(System.Reflection.MethodBase.GetCurrentMethod().Name);
			}
			
			UnityEngine.Debug.LogWarning("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			
			yield return null;
		}
//		
//		
//		public void testBalanceGate() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_balancegate";
//			Level lvl1 = new Level(lvl1Id);
//			string lvl2Id = "lvl2_balancegate";
//			Level lvl2 = new Level(lvl2Id);
//			string itemId = ITEM_ID_BALANCE_GATE;
//			string balanceGateId = "balance_gate";
//			
//			BalanceGate balanceGate = new BalanceGate(balanceGateId, itemId, 1);
//			lvl2.addGate(balanceGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds, null);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			
//			// set up events expectations (async)
//			//mExpectedWorldEventId = lvl1Id;
//			//mExpectedGateEventId = balanceGateId;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 1, 1));
//			
//			lvl1.Start();
//			
//			Assert.assertFalse(balanceGate.IsOpen());
//			Assert.assertFalse(balanceGate.CanOpen());
//			
//			try {
//				StoreInventory.GiveItem(itemId, 1);
//				Assert.assertTrue(balanceGate.CanOpen());
//				
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e);
//			}
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(balanceGate.IsOpen());
//			Assert.assertTrue(balanceGate.CanOpen());
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, -1, 0));
//			
//			bool opened = balanceGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(balanceGate.IsOpen());
//			Assert.assertTrue(balanceGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl2Id;
//			
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}
//		
//		
//		public void testWorldCompletionGate() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_completiongate";
//			Level lvl1 = new Level(lvl1Id);
//			string lvl2Id = "lvl2_completiongate";
//			Level lvl2 = new Level(lvl2Id);
//			string worldGateId = "world_gate";
//			
//			WorldCompletionGate lvl1CompletionGate =
//				new WorldCompletionGate(worldGateId, lvl1Id);
//			lvl2.Gates.Gates.Add(lvl1CompletionGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl1Id;
//			
//			lvl1.Start();
//			
//			Assert.assertFalse(lvl1CompletionGate.IsOpen());
//			Assert.assertFalse(lvl1CompletionGate.CanOpen());
//			
//			// set up events expectations (async)
//			//mExpectedGateEventId = worldGateId;
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(lvl1CompletionGate.IsOpen());
//			Assert.assertTrue(lvl1CompletionGate.CanOpen());
//			
//			bool opened = lvl1CompletionGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(lvl1CompletionGate.IsOpen());
//			Assert.assertTrue(lvl1CompletionGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl2Id;
//			
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}

//		public void testPurchasableGate(bool vi) {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_purchasablegate";
//			Level lvl1 = new Level(lvl1Id);
//			Level lvl2 = new Level("lvl2_purchasablegate");
//			string itemId = vi ? ITEM_ID_PURCHASE_GATE_VI : ITEM_ID_PURCHASE_GATE_MARKET;
//			string purchaseGateId = vi ? "purchase_gate_vi": "purchase_gate_market";
//			
//			PurchasableGate purchasableGate = new PurchasableGate(purchaseGateId, itemId);
//			lvl2.addGate(purchasableGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			lvl1.Start();
//			
//			Assert.assertFalse(purchasableGate.IsOpen());
//			Assert.assertFalse(purchasableGate.CanOpen());
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(purchasableGate.IsOpen());
//			Assert.assertTrue(purchasableGate.CanOpen());
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 10, 10));
//			
//			try {
//				StoreInventory.GiveItem(itemId, 10);
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, -10, 0));
//			
//			try {
//				StoreInventory.BuyItem(itemId);
//			} catch (InsufficientFundsException e) {
//				Assert.fail(e.ToString());
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			bool opened = purchasableGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(purchasableGate.IsOpen());
//			Assert.assertTrue(purchasableGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}
		
		 /* should pass iff GatesList.mAutoOpenBehavior == false */
//		public void testGatesList() {
//			string recordGateId1 = "gates_list_record_gate_id1";
//			string scoreId1 = "gates_list_score_id1";
//			double desiredRecord1 = 100;
//			string recordGateId2 = "gates_list_record_gate_id2";
//			string scoreId2 = "gates_list_score_id2";
//			double desiredRecord2 = 200;
//			
//			Score score1 = new Score(scoreId1, "GatesListScore1", true);
//			Score score2 = new Score(scoreId2, "GatesListScore2", true);
//			
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_gates_list";
//			Level lvl1 = new Level(lvl1Id);
//			lvl1.addScore(score1);
//			lvl1.addScore(score2);
//			worlds.Add(lvl1);
//			
//			RecordGate recordGate1 = new RecordGate(recordGateId1, scoreId1, desiredRecord1);
//			RecordGate recordGate2 = new RecordGate(recordGateId2, scoreId2, desiredRecord2);
//			
//			List<Gate> gates = new List<Gate>();
//			gates.Add(recordGate1);
//			gates.Add(recordGate2);
//			
//			string gateListORId = "gate_list_OR_id";
//			GatesListOR gatesListOR = new GatesListOR(gateListORId, gates);
//			
//			string gateListANDId = "gate_list_AND_id";
//			GatesListAND gatesListAND = new GatesListAND(gateListANDId, gates);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			//mExpectedGateEventId = recordGateId1;
//			//mExpectedScoreEventId = scoreId1;
//			//mExpectedRecordValue = desiredRecord1;
//			
//			score1.SetTempScore(desiredRecord1);
//			score1.SaveAndReset();
//			
//			Assert.assertTrue(recordGate1.CanOpen());
//			Assert.assertFalse(recordGate1.IsOpen());
//			
//			//mExpectedGatesListEventId = gateListORId;
//			
//			Assert.assertTrue(recordGate1.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertFalse(gatesListOR.IsOpen());
//			
//			Assert.assertFalse(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			Assert.assertTrue(gatesListOR.TryOpen());
//			
//			//mExpectedGateEventId = recordGateId2;
//			//mExpectedScoreEventId = scoreId2;
//			//mExpectedRecordValue = desiredRecord2;
//			
//			score2.SetTempScore(desiredRecord2);
//			score2.SaveAndReset();
//			
//			Assert.assertTrue(recordGate2.CanOpen());
//			Assert.assertFalse(recordGate2.IsOpen());
//			
//			//mExpectedGatesListEventId = gateListANDId;
//			
//			Assert.assertTrue(recordGate2.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.TryOpen());
//			Assert.assertTrue(gatesListAND.IsOpen());
//		}
		
		 /* should pass iff GatesList.mAutoOpenBehavior == true */
//		public void testGatesListAutoOpenBehavior() {
//			//        GatesList.mChildrenCanOpenIsEnough = true;
//			//        GatesList.mAutoOpenBehavior = true;
//			
//			string recordGateId1 = "gates_list_AO_record_gate_id1";
//			string scoreId1 = "gates_list_AO_score_id1";
//			double desiredRecord1 = 10;
//			string recordGateId2 = "gates_list_AO_record_gate_id2";
//			string scoreId2 = "gates_list_AO_score_id2";
//			double desiredRecord2 = 20;
//			
//			Score score1 = new Score(scoreId1, "GatesAOListScore1", true);
//			Score score2 = new Score(scoreId2, "GatesAOListScore2", true);
//			
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_gates_list_AO";
//			Level lvl1 = new Level(lvl1Id);
//			lvl1.addScore(score1);
//			lvl1.addScore(score2);
//			worlds.Add(lvl1);
//			
//			RecordGate recordGate1 = new RecordGate(recordGateId1, scoreId1, desiredRecord1);
//			RecordGate recordGate2 = new RecordGate(recordGateId2, scoreId2, desiredRecord2);
//			
//			List<Gate> gates = new List<Gate>();
//			gates.Add(recordGate1);
//			gates.Add(recordGate2);
//			
//			string gateListORId = "gate_list_AO_OR_id";
//			GatesListOR gatesListOR = new GatesListOR(gateListORId, gates);
//			
//			string gateListANDId = "gate_list_AO_AND_id";
//			GatesListAND gatesListAND = new GatesListAND(gateListANDId, gates);
//			
//			LevelUp.GetInstance().Initialize(worlds, null);
//			
//			//mExpectedGatesListEventId = gateListORId;
//			//mExpectedGateEventId = recordGateId1;
//			//mExpectedScoreEventId = scoreId1;
//			//mExpectedRecordValue = desiredRecord1;
//			
//			score1.SetTempScore(desiredRecord1);
//			score1.SaveAndReset();
//			
//			Assert.assertTrue(recordGate1.CanOpen());
//			Assert.assertFalse(recordGate1.IsOpen());
//			
//			Assert.assertTrue(recordGate1.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertFalse(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.TryOpen());
//			
//			//mExpectedGatesListEventId = gateListANDId;
//			//mExpectedGateEventId = recordGateId2;
//			//mExpectedScoreEventId = scoreId2;
//			//mExpectedRecordValue = desiredRecord2;
//			
//			score2.SetTempScore(desiredRecord2);
//			score2.SaveAndReset();
//			
//			Assert.assertTrue(recordGate2.CanOpen());
//			Assert.assertFalse(recordGate2.IsOpen());
//			
//			Assert.assertTrue(recordGate2.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.CanOpen());
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListAND.IsOpen());
//			
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.TryOpen());
//			Assert.assertTrue(gatesListAND.IsOpen());
//		}
		
		
//		public void testVirtualItemScore() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_viscore";
//			Level lvl1 = new Level(lvl1Id);
//			string itemId = ITEM_ID_VI_SCORE;
//			string scoreId = "vi_score";
//			VirtualItemScore virtualItemScore = new VirtualItemScore(
//				scoreId, "VI_Score", itemId);
//			lvl1.addScore(virtualItemScore);
//			
//			worlds.Add(lvl1);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			try {
//				Assert.assertEquals(0, StoreInventory.GetItemBalance(itemId));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// set up events expectations (async)
//			//mExpectedWorldEventId = lvl1Id;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 2, 2));
//			//mExpectedScoreEventId = scoreId;
//			//mExpectedRecordValue = 2;
//			
//			lvl1.Start();
//			virtualItemScore.Inc(2);
//			lvl1.End(true);
//			
//			try {
//				Assert.assertEquals(2, StoreInventory.GetItemBalance(itemId));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//		}
		
		
//		public void testCounts() {
//			
//			
//			List<World> worlds = new List<World>();
//			Level level1 = new Level("level1");
//			Level level2 = new Level("level2");
//			Level level2_1 = new Level("level2_1");
//			level2.addInnerWorld(level2_1);
//			
//			World world1 = new World("world1");
//			world1.addInnerWorld(level1);
//			world1.addInnerWorld(level2);
//			
//			World world2 = new World("world2");
//			
//			World world3 = new World("world3");
//			World world3_1 = new World("world3_1");
//			World world3_2 = new World("world3_2");
//			
//			Level level3_1_1 = new Level("level3_1_1");
//			Level level3_1_2 = new Level("level3_1_2");
//			Level level3_1_1_1 = new Level("level3_1_1_1");
//			level3_1_1.addInnerWorld(level3_1_1_1);
//			world3_1.addInnerWorld(level3_1_1);
//			world3_1.addInnerWorld(level3_1_2);
//			
//			world3.addInnerWorld(world3_1);
//			world3.addInnerWorld(world3_2);
//			
//			worlds.Add(world1);
//			worlds.Add(world2);
//			worlds.Add(world3);
//			
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCount(), 6);
//			Assert.assertEquals(LevelUp.GetInstance().GetWorldCount(false), 5);
//			Assert.assertEquals(LevelUp.GetInstance().GetWorldCount(true), 6 + 5);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world1), 3);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world2), 0);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world3), 3);
//			
//			// Test before world completion
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedLevelCount(), 0);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedWorldCount(), 0);
//			
//			// Test after world completion
//			// TODO: Decouple event expectations from test
//			//mExpectedWorldEventId = level1.getWorldId();
//			level1.SetCompleted(true);
//			//mExpectedWorldEventId = level3_1_1_1.getWorldId();
//			level3_1_1_1.SetCompleted(true);
//			//mExpectedWorldEventId = world1.getWorldId();
//			world1.SetCompleted(true);
//			//mExpectedWorldEventId = world3_1.getWorldId();
//			world3_1.SetCompleted(true);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedLevelCount(), 2);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedWorldCount(), 2);
//		}
		
		// EVENT HANDLERS - TESTING EVENTS
		// event handlers take the next expected event from the queue
		// make sure the correct handler was called, the correct event
		// and properties that the test expected

		private void onGateOpen(Gate gate) {
			string gateId = gate.ID;
			bool isGatesList = gate is GatesList;
			bool isAdHocGate = UUID_REGEX.IsMatch (gateId);
			string msg = "<color=yellow>onEvent/onGateOpen:</color>" + gateId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onGateOpen _eventQueue.Count="+_eventQueue.Count);

//			string expectedGateEventId = isGatesList ?
//				(isAdHocGate ? gateId : mExpectedGatesListEventId) :
//					expected["id"];

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], gateId);
		}
		
		private void onLevelEnded(Level level) {
			string worldId = level.ID;
			string msg = "<color=yellow>onEvent/onLevelEnded:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onLevelEnded _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], worldId);
		}
		
		private void onLevelStarted(Level level) {
			string worldId = level.ID;
			string msg = "<color=yellow>onEvent/onLevelStarted:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			SoomlaUtils.LogWarning (TAG, "onLevelStarted _eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], worldId);
		}
		
		private void onMissionCompleted(Mission mission) {
			string missionId = mission.ID;
			bool isChallenge = mission is Challenge;
			string msg = "<color=yellow>onEvent/onMissionCompleted:</color>" + missionId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onMissionCompleted _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], missionId);
		}
		
		private void onMissionCompletedRevoked(Mission mission) {
			string missionId = mission.ID;
			bool isChallenge = mission is Challenge;
			string msg = "<color=yellow>onEvent/onMissionCompletedRevoked:</color>" + missionId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onMissionCompletedRevoked _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], missionId);
		}
		
		private void onScoreRecordChanged(Score score) {
			string scoreId = score.ID;
			double record = score.Record;
			string msg = "<color=yellow>onEvent/onScoreRecordChanged:</color>" + score + "->" + record;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onScoreRecordChanged _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], scoreId);
			Assert.assertEquals(expected["val"] as double? ?? 0.9999, record, 0.1);
		}
		
		private void onWorldCompleted(World world) {
			string worldId = world.ID;
			string msg = "<color=yellow>onEvent/onWorldCompleted:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onWorldCompleted _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], worldId);
		}

		private void onGoodBalanceChanged(VirtualGood vg, int balance, int amountAdded) {
			string itemId = vg.ItemId;
			string msg = "<color=yellow>onEvent/GoodBalanceChangedEvent:</color>" + itemId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogDebug(TAG, DictToString(expected));
			SoomlaUtils.LogWarning (TAG, "onGoodBalanceChanged _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["itemId"], itemId);
			Assert.assertEquals(expected["balance"], balance);
			Assert.assertEquals(expected["added"], amountAdded);
		}

		private void onRewardGiven(Reward reward) {
			string rewardId = reward.ID;
			string msg = "<color=yellow>onEvent/onRewardGiven:</color>" + rewardId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onRewardGiven _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], rewardId);
		}

		private void onRewardTaken(Reward reward) {
			string rewardId = reward.ID;
			string msg = "<color=yellow>onEvent/onRewardTaken:</color>" + rewardId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogWarning (TAG, "onRewardTaken _eventQueue.Count="+_eventQueue.Count);

			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
			Assert.assertEquals(expected["id"], rewardId);
		}

		public class Coroutine<T>{
			public T Value {
				get{
					if(e != null){
						throw e;
					}
					return returnVal;
				}
			}
			private T returnVal;
			private Exception e;
			public Coroutine coroutine;
			
			public IEnumerator InternalRoutine(IEnumerator coroutine){
				while(true){
					try{
						if(!coroutine.MoveNext()){
							yield break;
						}
					}
					catch(Exception e){
						this.e = e;
						yield break;
					}
					object yielded = coroutine.Current;
					if(yielded != null && yielded.GetType() == typeof(T)){
						returnVal = (T)yielded;
						yield break;
					}
					else{
						yield return coroutine.Current;
					}
				}
			}
		}
	}
}
